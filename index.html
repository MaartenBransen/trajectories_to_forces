<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>trajectories_to_forces API documentation</title>
<meta name="description" content="Description
Python package with a set of functions for extracting pairwise interaction
forces from particle trajectories under overdamped (Brownian) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>trajectories_to_forces</code></h1>
</header>
<section id="section-intro">
<h2 id="description">Description</h2>
<p>Python package with a set of functions for extracting pairwise interaction
forces from particle trajectories under overdamped (Brownian) or inertial
(molecular) dynamics.</p>
<p>The codes for this package were developed as part of the work in reference [1],
based on the concepts in reference [2].</p>
<h2 id="references">References</h2>
<p>[1] Bransen, M. (2024). Measuring interactions between colloidal
(nano)particles. PhD thesis, Utrecht University.</p>
<p>[2] Jenkins, I. C., Crocker, J. C., &amp; Sinno, T. (2015). Interaction potentials
from arbitrary multi-particle trajectory data. Soft Matter, 11(35), 6948–6956.
<a href="https://doi.org/10.1039/C5SM01233C">https://doi.org/10.1039/C5SM01233C</a></p>
<h2 id="license">License</h2>
<p>MIT license</p>
<p>Copyright (c) 2024 Maarten Bransen</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="trajectories_to_forces.convert_cylindrical_force_axes"><code class="name flex">
<span>def <span class="ident">convert_cylindrical_force_axes</span></span>(<span>binmean_z, binmean_rho, G_z, G_rho)</span>
</code></dt>
<dd>
<div class="desc"><p>convert the force coefficients along rho and z axes to the absolute value
and force as well as the coefficient values parallel and perpendicular to
the particle-particle vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>binmean_z</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>count weighted mean z distance for all pairs in each bin.</dd>
<dt><strong><code>binmean_rho</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>count weighted mean rho distance for all pairs in each bin.</dd>
<dt><strong><code>G_z</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients along z.</dd>
<dt><strong><code>G_rho</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients along rho.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>G_abs</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>absolute value of the force coefficients, i.e. net force scalar.</dd>
<dt><strong><code>G_ang</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>(clockwise) angle of the force vector w.r.t. the z axis in radians.</dd>
<dt><strong><code>G_para</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients for the force parallel to the particle-particle
vector.</dd>
<dt><strong><code>G_perp</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients for the force perpendicular to the particle-particle
vector.</dd>
</dl></div>
</dd>
<dt id="trajectories_to_forces.filter_msd"><code class="name flex">
<span>def <span class="ident">filter_msd</span></span>(<span>coordinates, times=None, pos_cols=('z', 'y', 'x'), msd_min=0.01, msd_max=1, interval=1)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates the squared displacement between subsequent frames for each
particle individually, meaned over all intervals, and filters the indices
by some threshold displacement</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>pandas.DataFrame</code></dt>
<dd>A pandas dataframe containing coordinates for each timestep. Must be
indexed by particle (with each particle having a unique identifyer that
matches between different time steps) and contain coordinates along
each dimension in a separate column, with column names matching those
given in <code>pos_cols</code>.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>timestamps for the sets of coordinates</dd>
<dt><strong><code>pos_cols</code></strong> :&ensp;<code>tuple</code> of <code>str</code>, optional</dt>
<dd>names of the columns of the DataFrames in <code>coordinates</code> containing the
particle coordinates along each dimension. The length (i.e. number of
dimensions) must match len(boundary) and the number of columns in
<code>coordinates</code>. The default is <code>('z','y','x')</code>.</dd>
<dt><strong><code>msd_min</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Lower limit for the mean squared displacement between two
time steps
below which a particle is considered stationary. The default is 0.01.</dd>
<dt><strong><code>msd_max</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Upper limit on the MSD between two timesteps. The default is 1.</dd>
<dt><strong><code>interval</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>time interval in integer index units used for the calculations, e.g.
averaging over neigbouring steps or over larger intervals than the
sampling rate in the data. The default is 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>set</code></dt>
<dd>particle identifiers for the particles which are NOT considered
stationary, i.e. those whose MSD is LARGER than the threshold.</dd>
<dt><strong><code>msds</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>full list of the MSD values for all particles in all timesteps, useful
e.g. for plotting a histogram to estimate a value for <code>threshold</code>.</dd>
</dl></div>
</dd>
<dt id="trajectories_to_forces.load_forceprofile"><code class="name flex">
<span>def <span class="ident">load_forceprofile</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>load results file as stored by <code><a title="trajectories_to_forces.save_forceprofile" href="#trajectories_to_forces.save_forceprofile">save_forceprofile()</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename with extension to store data in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>np.ndarray</code> of <code>int</code></dt>
<dd>bin indices</dd>
<dt><strong><code>r_cent</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>center r position of each bin.</dd>
<dt><strong><code>G</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients.</dd>
<dt><strong><code>G_err</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>residual error in G.</dd>
<dt><strong><code>binmean_r</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>count weighted mean distance for all pairs in each bin.</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>np.ndarray</code> of <code>int</code> or <code>float</code></dt>
<dd>number of pair counts in each bin weighted for the basis functions.</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>int</code></dt>
<dd>number of discretisation steps</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>cut-off distance for the force.</dd>
<dt><strong><code>basis_function</code></strong> :&ensp;<code>str</code></dt>
<dd>type of basis functions used.</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>friction factor used for the calculations.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether periodic boundary conditions were used.</dd>
</dl></div>
</dd>
<dt id="trajectories_to_forces.load_forceprofile_cylindrical"><code class="name flex">
<span>def <span class="ident">load_forceprofile_cylindrical</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>load results file as stored by <code><a title="trajectories_to_forces.save_forceprofile_cylindrical" href="#trajectories_to_forces.save_forceprofile_cylindrical">save_forceprofile_cylindrical()</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename with extension to store data in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>m_z</code></strong> :&ensp;<code>np.ndarray</code> of <code>int</code></dt>
<dd>z bin indices</dd>
<dt><strong><code>m_rho</code></strong> :&ensp;<code>np.ndarray</code> of <code>int</code></dt>
<dd>rho bin indices.</dd>
<dt><strong><code>z_cent</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>z position of center of each bin.</dd>
<dt><strong><code>rho_cent</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>rho position of center of each bin.</dd>
<dt><strong><code>G_z</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients along z.</dd>
<dt><strong><code>G_rho</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients along rho.</dd>
<dt><strong><code>G_z_err</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>residual error in G_z.</dd>
<dt><strong><code>G_rho_err</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>residual error in G_rho.</dd>
<dt><strong><code>binmean_z</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>count weighted mean z distance for all pairs in each bin.</dd>
<dt><strong><code>binmean_rho</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>count weighted mean rho distance for all pairs in each bin.</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>np.ndarray</code> of <code>int</code> or <code>float</code></dt>
<dd>number of pair counts in each bin weighted for the basis functions.</dd>
<dt><strong><code>M_z</code></strong> :&ensp;<code>int</code></dt>
<dd>number of discretisation steps along the z axis</dd>
<dt><strong><code>M_rho</code></strong> :&ensp;<code>int</code></dt>
<dd>number of discretisation steps along the rho axis.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>cut-off distance for the force.</dd>
<dt><strong><code>basis_function</code></strong> :&ensp;<code>str</code></dt>
<dd>type of basis functions used.</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>friction factor used for the calculations.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether periodic boundary conditions were used.</dd>
</dl></div>
</dd>
<dt id="trajectories_to_forces.run_inertial"><code class="name flex">
<span>def <span class="ident">run_inertial</span></span>(<span>coordinates, times, boundary=None, mass=1, rmax=1, M=20, pos_cols=['z', 'y', 'x'], periodic_boundary=False, bruteforce=False, remove_near_boundary=False, solve_per_dim=False, return_data=False, neighbour_upper_bound=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the analysis for inertial dynamics (molecular dynamics like), iterates
over all subsequent sets of three timesteps and obtains forces from the
accellerations of the particles. Based on [1].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>list</code> of <code>pandas.DataFrame</code></dt>
<dd>A pandas dataframe containing coordinates for each timestep. Must be
indexed by particle (with each particle having a unique identifyer that
matches between different time steps) and contain coordinates along
each dimension in a separate column, with column names matching those
given in <code>pos_cols</code>.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>list timestamps corresponding to the coordinates with length matching
<code>len(coordinates)</code>.</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>list</code> or <code>tuple</code>, optional</dt>
<dd>boundaries of the box in which the coordinates are defined in the form
((d0_min,d0_max),(d1_min,d1_max),&hellip;) with a length (number) and order
of dimensions matching <code>pos_cols</code>. The default is <code>None</code>, which uses
the min and max value found in the entire set of coordinates along each
axis.</dd>
<dt><strong><code>mass</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>particle mass for calculation of F=m*a. The default is 1.</dd>
<dt><strong><code>pos_cols</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>names of the columns of the DataFrames in <code>coordinates</code> containing the
particle coordinates along each dimension. The length (i.e. number of
dimensions) must match len(boundary) and the number of columns in
<code>coordinates</code>. The default is `['z','y','x'].</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>cut-off radius for calculation of the pairwise forces. The default is
1.</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of discretization steps for the force profile, i.e. the
number of bins from 0 to rmax into which the data will be sorted. The
default is 20.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether the box has periodic boundary conditions. If True, the boundary
must be given. The default is False.</dd>
<dt><strong><code>bruteforce</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the coefficients are calculated in a naive brute-force
approach with a nested loop over all particles. The default is False,
which uses a scipy.spatial.cKDTree based approach to only evaluate
pairs which are &lt;rmax apart.</dd>
<dt><strong><code>remove_near_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, particles which are closer than rmax from any of the
boundaries are not analyzed, but still accounted for when analyzing
particles closer to the center of the box in order to only analyze
particles for which the full spherical shell up to rmax is within the
box of coordinates, and to prevent erroneous handling of particles
which interact with other particles outside the measurement volume.
Only possible when periodic_boundary=False. The default is True.</dd>
<dt><strong><code>solve_per_dim</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, the matrix is solved for each dimension separately, and a
force vector and error are returned for each dimension.</dd>
<dt><strong><code>return_data</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the full coefficient matrix and force vector are returned
together with the force vector, error and the list of bincounts. The
default is False.</dd>
<dt><strong><code>neighbour_upper_bound</code></strong> :&ensp;<code>int</code></dt>
<dd>upper bound on the number of neighbours within rmax a particle may have
to limit memory use and computing time in the pair finding step. The
default is the total number of particles in each time step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>numpy.array</code> of <code>length M</code></dt>
<dd>discretized force vector, the result of the computation.</dd>
<dt><strong><code>G_err</code></strong> :&ensp;<code>numpy.array</code> of <code>length M</code></dt>
<dd>errors in G based on the least_squares solution of the matrix equation</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>numpy.array</code> of <code>length M</code></dt>
<dd>number of individual force evaluations contributing to the result in
each bin.</dd>
<dt><strong><code>coefficients</code></strong> :&ensp;<code>numpy.array</code> of <code>M by 3n*(len(times)-1)</code></dt>
<dd>coefficient matrix of the full dataset as specified in [1]. This is
only returned when <code>return_data=True</code></dd>
<dt><strong><code>forces</code></strong> :&ensp;<code>numpy.array</code> of <code>length 3n*(len(times)-1)</code></dt>
<dd>vector of particle forces of form [t0p0z,t0p0y,t0p0x,t0p1z,t0p1y, &hellip;,
tn-1pnx]. This is only returned when <code>return_data=True</code></dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Jenkins, I. C., Crocker, J. C., &amp; Sinno, T. (2015). Interaction
potentials from arbitrary multi-particle trajectory data. Soft Matter,
11(35), 6948–6956. <a href="https://doi.org/10.1039/C5SM01233C">https://doi.org/10.1039/C5SM01233C</a></p></div>
</dd>
<dt id="trajectories_to_forces.run_overdamped"><code class="name flex">
<span>def <span class="ident">run_overdamped</span></span>(<span>coordinates, times, boundary=None, gamma=1, rmax=1, M=20, pos_cols=('z', 'y', 'x'), eval_particles=None, periodic_boundary=False, basis_function='constant', bruteforce=False, remove_near_boundary=True, constant_particles=False, solve_per_dim=False, neighbour_upper_bound=None, newline=False, use_gpu=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the analysis for overdamped dynamics (brownian dynamics like), iterates
over all subsequent sets of two timesteps and obtains forces from the
velocity of the particles as a function of the distribution of the
particles around eachother. Based on ref. [1].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>(list of) list</code> of <code>pandas.DataFrame</code></dt>
<dd>A pandas dataframe containing coordinates for each timestep as a series
of consecutive timesteps of at least 2 items (i.e. 1 time interval).
Multiple nonconsecutive series may be given as list of lists of
DataFrames. DataFrames must be indexed by particle (with each particle
having a unique identifyer that matches between different time steps)
and contain coordinates along each dimension in a separate column, with
column names matching those given in <code>pos_cols</code>.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>(list of) list</code> of <code>float</code></dt>
<dd>list(s) of timestamps corresponding to the coordinate sets</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>tuple, list</code> of <code>tuple</code> or <code>list</code> of <code>list</code> of <code>tuple</code>, optional</dt>
<dd>boundaries of the box in which the coordinates are defined in the form
((d0_min,d0_max),(d1_min,d1_max),&hellip;) with a length (number) and order
of dimensions matching <code>pos_cols</code>. A single set of boundaries may be
given for all timesteps, or a (list of) list of boundaries for each
timestep may be specified. The default is <code>None</code>, which uses the min
and max value found in the entire set of coordinates along each axis.</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>damping/friction coefficient (kT/D) for calculation of F=V*kT/D. The
default is 1.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>cut-off radius for calculation of the pairwise forces. The default is
1.</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of discretization steps for the force profile, i.e. the
number of bins from 0 to rmax into which the data will be sorted. The
default is 20.</dd>
<dt><strong><code>pos_cols</code></strong> :&ensp;<code>tuple</code> of <code>str</code>, optional</dt>
<dd>names of the columns of the DataFrames in <code>coordinates</code> containing the
particle coordinates along each dimension. The length (i.e. number of
dimensions) must match len(boundary) and the number of columns in
<code>coordinates</code>. The default is <code>('z','y','x')</code>.</dd>
<dt><strong><code>eval_particles</code></strong> :&ensp;<code>set</code></dt>
<dd>set of particle id's (matching the indices in <code>coordinates</code>) to use in
the force evaluation, such that forces are not calculated for any
particle not in the set of eval_particles. Note that all particles are
always used to calculate the coefficients.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether the box has periodic boundary conditions. If True, the boundary
must be given. The default is False.</dd>
<dt><strong><code>basis_function</code></strong> :&ensp;<code>['constant', 'linear']</code></dt>
<dd>the type of basis functions to use, where <code>'constant'</code> uses square wave
basis functions which assume the force is constant over each bin, and
<code>'linear'</code> uses linear wave basis functions where each pair contributes
to the nearby bins with linearly interpolated weights. The default is
<code>'constant'</code>.</dd>
<dt><strong><code>bruteforce</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the coefficients are calculated in a naive brute-force
approach with a nested loop over all particles. The default is False,
which uses a scipy.spatial.cKDTree based approach to only evaluate
pairs which are &lt;rmax apart.</dd>
<dt><strong><code>remove_near_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, particles which are closer than rmax from any of the
boundaries are not analyzed, but still accounted for when analyzing
particles closer to the center of the box in order to only analyze
particles for which the full spherical shell up to rmax is within the
box of coordinates, and to prevent erroneous handling of particles
which interact with other particles outside the measurement volume.
Only possible when periodic_boundary=False. The default is True.</dd>
<dt><strong><code>constant_particles</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>when the same set of particles is present in each timestep, i.e. the
indices of coordinates are identical for all time steps after selecting
<code>eval_particles</code>, more efficient (indexing) algorithms can be used</dd>
<dt><strong><code>solve_per_dim</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, the matrix is solved for each dimension separately, and a
force vector and error are returned for each dimension.</dd>
<dt><strong><code>neighbour_upper_bound</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>upper bound on the number of neighbours within rmax a particle may have
to limit memory use and computing time in the pair finding step. The
default is the total number of particles in each time step.</dd>
<dt><strong><code>newline</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to print output for each series on a new line. The default is
True.</dd>
<dt><strong><code>use_gpu</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, matrix operations for the least squares solver are offloaded
to the gpu via CuPy, which requires a cuda-compatible gpu. For large
numbers of bins (&gt;&gt;100) this may result in significantly better
performance but there is considerable overhead in moving data between
cpu and gpu, so for most use cases this is not faster.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>numpy.array</code> of <code>length M</code></dt>
<dd>discretized force vector, the result of the computation.</dd>
<dt><strong><code>G_err</code></strong> :&ensp;<code>numpy.array</code> of <code>length M</code></dt>
<dd>errors in G based on the least_squares solution of the matrix equation</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>numpy.array</code> of <code>length M</code></dt>
<dd>number of individual force evaluations contributing to the result in
each bin.</dd>
<dt><strong><code>mean_rho</code></strong> :&ensp;<code>numpy.array</code> of <code>length M</code></dt>
<dd>the average interparticle distance of all particle pairs contributing
to each bin, i.e. the mean of the distances for which the forces were
evaluated.</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Jenkins, I. C., Crocker, J. C., &amp; Sinno, T. (2015). Interaction
potentials from arbitrary multi-particle trajectory data. Soft Matter, 11
(35), 6948–6956. <a href="https://doi.org/10.1039/C5SM01233C">https://doi.org/10.1039/C5SM01233C</a></p></div>
</dd>
<dt id="trajectories_to_forces.run_overdamped_cylindrical"><code class="name flex">
<span>def <span class="ident">run_overdamped_cylindrical</span></span>(<span>coordinates, times, boundary=None, gamma=1, rmax=1, M_z=20, M_rho=20, pos_cols=('z', 'y', 'x'), eval_particles=None, periodic_boundary=False, basis_function='constant', remove_near_boundary=True, constant_particles=False, neighbour_upper_bound=None, use_gpu=False, check_coordinates=True, newline=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the analysis for overdamped dynamics (brownian dynamics like) in a
cylindrical coordinate system where interactions are radially averaged in
the xy plane (dimensions 2 and 1) but not along the cylinder (z) axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>(list of) list</code> of <code>pandas.DataFrame</code></dt>
<dd>A pandas dataframe containing coordinates for each timestep as a series
of consecutive timesteps of at least 2 items (i.e. 1 time interval).
Multiple nonconsecutive series may be given as list of lists of
DataFrames. DataFrames must be indexed by particle (with each particle
having a unique identifyer that matches between different time steps)
and contain coordinates along each dimension in a separate column, with
column names matching those given in <code>pos_cols</code>.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>(list of) list</code> of <code>float</code></dt>
<dd>list(s) of timestamps corresponding to the coordinate sets</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>tuple, list</code> of <code>tuple</code> or <code>list</code> of <code>list</code> of <code>tuple</code>, optional</dt>
<dd>boundaries of the box in which the coordinates are defined in the form
((d0_min,d0_max),(d1_min,d1_max),&hellip;) with a length (number) and order
of dimensions matching <code>pos_cols</code>. A single set of boundaries may be
given for all timesteps, or a (list of) list of boundaries for each
timestep may be specified. The default is <code>None</code>, which uses the min
and max value found in the entire set of coordinates along each axis.</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>damping/friction coefficient (kT/D) for calculation of F=V*kT/D. The
default is 1.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>cut-off radius for calculation of the pairwise forces. The default is
1.</dd>
<dt><strong><code>M_z</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of discretization steps for the force profile along the z
(cylinder) direction, i.e. the number of bins from 0 to rmax into which
the data will be sorted. The default is 20.</dd>
<dt><strong><code>M_rho</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of discretization steps along the axial (rho) direction. The
default is 20.</dd>
<dt><strong><code>pos_cols</code></strong> :&ensp;<code>tuple</code> of <code>str</code>, optional</dt>
<dd>names of the columns of the DataFrames in <code>coordinates</code> containing the
particle coordinates along each dimension. The first is assumed to be
the axial (z) direction and the second and third define the plane for
the rho component. The default is <code>('z','y','x')</code>.</dd>
<dt><strong><code>eval_particles</code></strong> :&ensp;<code>set</code>, optional</dt>
<dd>set of particle id's (matching the indices in <code>coordinates</code>) to use in
the force evaluation, such that forces are not calculated for any
particle not in the set of eval_particles. Note that all particles are
always used to calculate the coefficients. The default is to evaluate
all particles in <code>coordinates</code>.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether the box has periodic boundary conditions. If True, the boundary
must be given. The default is False.</dd>
<dt><strong><code>basis_function</code></strong> :&ensp;<code>['constant', 'linear']</code></dt>
<dd>the type of basis functions to use, where <code>'constant'</code> uses square wave
basis functions which assume the force is constant over each bin, and
<code>'linear'</code> uses linear wave basis functions where each pair contributes
to the nearby bins with linearly interpolated weights. The default is
<code>'constant'</code>.</dd>
<dt><strong><code>remove_near_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, particles which are closer than rmax from any of the
boundaries are not analyzed, but still accounted for when analyzing
particles closer to the center of the box in order to only analyze
particles for which the full spherical shell up to rmax is within the
box of coordinates, and to prevent erroneous handling of particles
which interact with other particles outside the measurement volume.
Only possible when periodic_boundary=False. The default is True.</dd>
<dt><strong><code>constant_particles</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>when the same set of particles is present in each timestep, i.e. the
indices of coordinates are identical for all time steps after selecting
<code>eval_particles</code>, more efficient (indexing) algorithms can be used</dd>
<dt><strong><code>neighbour_upper_bound</code></strong> :&ensp;<code>int</code></dt>
<dd>upper bound on the number of neighbours within rmax a particle may have
to limit memory use and computing time in the pair finding step. The
default is the total number of particles in each time step.</dd>
<dt><strong><code>use_gpu</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, matrix operations for the least squares solver are offloaded
to the gpu via CuPy, which requires a cuda-compatible gpu. For large
numbers of bins (M_z×M_rho&gt;&gt;100) this may result in significantly
better performance. There is considerable overhead in moving data
between cpu and gpu, so for small numbers of bins this is not faster.</dd>
<dt><strong><code>check_coordinates</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>by default, coordinates are checked for being within boundaries. This
can be bypassed by setting this to False.</dd>
<dt><strong><code>newline</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to print output for each series on a new line. The default is
True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>m_z</code></strong> :&ensp;<code>numpy.array</code> of <code>ints</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>z axis bin indices corresponding to the data arrays.</dd>
<dt><strong><code>m_rho</code></strong> :&ensp;<code>numpy.array</code> of <code>ints</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>rho axis bin indices corresponding to the data arrays.</dd>
<dt><strong><code>G_z</code></strong> :&ensp;<code>numpy.array</code> of <code>floats</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>values for the axial (z) component of the force in each bin, i.e. the
magnitude associated with each basis function.</dd>
<dt><strong><code>G_rho</code></strong> :&ensp;<code>numpy.array</code> of <code>floats</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>values for the in-plane (rho) component of the force in each bin, i.e.
the magnitude associated with each basis function.</dd>
<dt><strong><code>G_z_err</code></strong> :&ensp;<code>numpy.array</code> of <code>floats</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>residual least-squares error in each bin in G_z</dd>
<dt><strong><code>G_rho_err</code></strong> :&ensp;<code>numpy.array</code> of <code>floats</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>residual least-squares error in each bin in G_rho</dd>
<dt><strong><code>mean_z</code></strong> :&ensp;<code>numpy.array</code> of <code>floats</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>the average absolute z distance of all particle pairs contributing to
each bin, i.e. the mean of the distances for which the forces were
evaluated.</dd>
<dt><strong><code>mean_rho</code></strong> :&ensp;<code>numpy.array</code> of <code>floats</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>the average absolute planar (rho) distance of all particle pairs
contributing to each bin, i.e. the mean of the distances for which the
forces were evaluated.</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>numpy.array</code> of <code>floats</code> of <code>shape (M_z,M_rho)</code></dt>
<dd>number of individual force evaluations contributing to the result in
each bin. When <code>basis_function='linear'</code> this is a total weight rather
than an integer count, since each particle pair has its unity weight
divided over the 4 surrounding bins.</dd>
</dl></div>
</dd>
<dt id="trajectories_to_forces.save_forceprofile"><code class="name flex">
<span>def <span class="ident">save_forceprofile</span></span>(<span>filename, rmax, M, basis_function, gamma, periodic_boundary, binmean_r, G, G_err, counts)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the results from trajectory analysis to a text file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>filename to use for results file</dd>
<dt><strong><code>binmean_r</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>mean value of all pairs in each bin, i.e. a 'count weighted' bin center</dd>
<dt><strong><code>forces</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>list of force values as obtained from the trajectory analysis</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>the number of evaluations used for each bin</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>int</code></dt>
<dd>number of bins</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>cut-off radius for force</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>the friction coefficient used in the calculation</dd>
</dl></div>
</dd>
<dt id="trajectories_to_forces.save_forceprofile_cylindrical"><code class="name flex">
<span>def <span class="ident">save_forceprofile_cylindrical</span></span>(<span>filename, rmax, M_z, M_rho, basis_function, gamma, periodic_boundary, m_z, m_rho, G_z, G_rho, G_z_err, G_rho_err, binmean_z, binmean_rho, counts)</span>
</code></dt>
<dd>
<div class="desc"><p>save results from cylindrical trajectory analysis to a file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename with extension to store data in.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>cut-off distance for the force.</dd>
<dt><strong><code>M_z</code></strong> :&ensp;<code>int</code></dt>
<dd>number of discretisation steps along the z axis</dd>
<dt><strong><code>M_rho</code></strong> :&ensp;<code>int</code></dt>
<dd>number of discretisation steps along the rho axis.</dd>
<dt><strong><code>basis_function</code></strong> :&ensp;<code>str</code></dt>
<dd>type of basis functions used.</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>friction factor used for the calculations.</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether periodic boundary conditions were used.</dd>
<dt><strong><code>m_z</code></strong> :&ensp;<code>np.ndarray</code> of <code>int</code></dt>
<dd>z bin indices</dd>
<dt><strong><code>m_rho</code></strong> :&ensp;<code>np.ndarray</code> of <code>int</code></dt>
<dd>rho bin indices.</dd>
<dt><strong><code>G_z</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients along z.</dd>
<dt><strong><code>G_rho</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>force coefficients along rho.</dd>
<dt><strong><code>G_z_err</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>residual error in G_z.</dd>
<dt><strong><code>G_rho_err</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>residual error in G_rho.</dd>
<dt><strong><code>binmean_z</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>count weighted mean z distance for all pairs in each bin.</dd>
<dt><strong><code>binmean_rho</code></strong> :&ensp;<code>np.ndarray</code> of <code>float</code></dt>
<dd>count weighted mean rho distance for all pairs in each bin.</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>np.ndarray</code> of <code>int</code> or <code>float</code></dt>
<dd>number of pair counts in each bin weighted for the basis functions.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#description">Description</a></li>
<li><a href="#references">References</a></li>
<li><a href="#license">License</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="trajectories_to_forces.convert_cylindrical_force_axes" href="#trajectories_to_forces.convert_cylindrical_force_axes">convert_cylindrical_force_axes</a></code></li>
<li><code><a title="trajectories_to_forces.filter_msd" href="#trajectories_to_forces.filter_msd">filter_msd</a></code></li>
<li><code><a title="trajectories_to_forces.load_forceprofile" href="#trajectories_to_forces.load_forceprofile">load_forceprofile</a></code></li>
<li><code><a title="trajectories_to_forces.load_forceprofile_cylindrical" href="#trajectories_to_forces.load_forceprofile_cylindrical">load_forceprofile_cylindrical</a></code></li>
<li><code><a title="trajectories_to_forces.run_inertial" href="#trajectories_to_forces.run_inertial">run_inertial</a></code></li>
<li><code><a title="trajectories_to_forces.run_overdamped" href="#trajectories_to_forces.run_overdamped">run_overdamped</a></code></li>
<li><code><a title="trajectories_to_forces.run_overdamped_cylindrical" href="#trajectories_to_forces.run_overdamped_cylindrical">run_overdamped_cylindrical</a></code></li>
<li><code><a title="trajectories_to_forces.save_forceprofile" href="#trajectories_to_forces.save_forceprofile">save_forceprofile</a></code></li>
<li><code><a title="trajectories_to_forces.save_forceprofile_cylindrical" href="#trajectories_to_forces.save_forceprofile_cylindrical">save_forceprofile_cylindrical</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>